## 测试指南

本项目包含单元测试和可能的集成测试，以确保代码质量和功能正确性。本文档将指导您如何运行和编写测试。

### 1. 测试框架与工具

本项目主要使用以下测试框架和工具：

*   **pytest**: 作为主要的测试框架，提供了简洁的测试编写方式和强大的插件系统。
*   **pytest-asyncio**: 用于在 `pytest` 中方便地测试异步代码 (FastAPI 应用)。
*   **pytest-mock**: 用于在测试中创建 Mock 对象，隔离被测试代码的依赖。
*   **httpx**: 一个现代化的 HTTP 客户端，用于编写集成测试，模拟对 FastAPI 应用的请求。

### 2. 运行测试

在项目根目录下，确保您已激活虚拟环境并安装了所有依赖 (`pip install -r requirements.txt`)。

*   **运行所有测试**:

    ```bash
    pytest
    ```

*   **运行特定模块的测试**:

    ```bash
    pytest tests/test_users_api.py
    ```

*   **运行特定测试函数**:

    ```bash
    pytest tests/test_users_api.py::test_create_user
    ```

*   **详细输出**: 使用 `-v` 标记获取更详细的测试结果输出。

    ```bash
    pytest -v
    ```

### 3. 编写单元测试

单元测试聚焦于代码中最小的可测试单元，例如函数或方法。目标是隔离被测试单元，验证其逻辑的正确性。

*   **测试文件命名**: 测试文件应以 `test_` 开头，例如 `test_utils.py`, `test_services.py`。
*   **测试函数命名**: 测试函数应以 `test_` 开头，例如 `test_send_email`, `test_get_user_by_id`。
*   **断言**: 使用 `assert` 语句来验证测试结果是否符合预期。
*   **Mocking**: 使用 `pytest-mock` 提供的 `mocker` fixture 来模拟外部依赖（如数据库调用、外部 API 请求、发送邮件等），确保测试的独立性。

**示例 (tests/test_utils.py)**:

```python
import pytest
from app.utils.email import send_email # 假设存在此模块

def test_send_email_success(mocker):
    # 模拟 smtplib 的 SMTP 对象和 sendmail 方法
    mock_smtp = mocker.Mock()
    mocker.patch('smtplib.SMTP', return_value=mock_smtp)

    to_email = 'test@example.com'
    subject = 'Test Subject'
    body = 'Test Body'

    send_email(to_email, subject, body)

    # 验证 SMTP 对象是否被创建并调用了 sendmail 方法
    mock_smtp.sendmail.assert_called_once_with('your_email@example.com', to_email, f'Subject: {subject}\n\n{body}')
    mock_smtp.quit.assert_called_once() # 验证是否关闭了连接

def test_send_email_failure(mocker):
    # 模拟 sendmail 方法抛出异常
    mock_smtp = mocker.Mock()
    mock_smtp.sendmail.side_effect = Exception("SMTP error")
    mocker.patch('smtplib.SMTP', return_value=mock_smtp)

    to_email = 'fail@example.com'
    subject = 'Fail Subject'
    body = 'Fail Body'

    with pytest.raises(Exception, match="SMTP error"):
        send_email(to_email, subject, body)

    mock_smtp.quit.assert_called_once() # 即使失败也应关闭连接
```

### 4. 编写集成测试

集成测试验证模块之间的交互以及应用与外部服务（如数据库）的集成。对于 FastAPI 应用，集成测试通常涉及启动应用的一个测试实例，并使用 HTTP 客户端向其发送请求。

*   **测试文件命名**: 集成测试文件通常也以 `test_` 开头，但可以放在单独的目录（如 `tests/integration`）或使用特定的命名约定（如 `test_*.py` 与 `test_integration_*.py`）。
*   **测试客户端**: 使用 FastAPI 的 `TestClient` 或 `httpx.Client` 来发送请求。
*   **数据库**: 集成测试可能需要连接到一个真实的或测试用的数据库。可以使用 `pytest` fixture 来管理测试数据库的 setup 和 teardown。

**示例 (tests/test_users_api.py - 使用 conftest.py 中的 client fixture)**:

```python
# from fastapi.testclient import TestClient # 如果直接使用 TestClient
# from app.main import app

# client = TestClient(app) # 如果直接使用 TestClient

def test_read_main(client):
    # client 是由 conftest.py 提供的 httpx.Client 或 TestClient fixture
    response = client.get("/") # 假设根路径有一个简单的GET接口
    assert response.status_code == 200
    assert response.json() == {"message": "Welcome to SiyuanTao Backend"}

def test_create_user(client):
    user_data = {
        "username": "testuser",
        "password": "securepassword",
        "email": "testuser@example.com"
    }
    # 假设 /api/v1/users 是创建用户的接口
    response = client.post("/api/v1/users", json=user_data)
    assert response.status_code == 201 # 假设创建成功返回 201
    created_user = response.json()
    assert "user_id" in created_user # 假设响应包含用户ID
    assert created_user["username"] == "testuser"
    # 更多断言... 验证数据库状态等（如果集成测试包含数据库）

# TODO: 添加更多用户 API 的集成测试
# test_get_user_profile,
# test_update_user_profile,
# test_login,
# test_request_magic_link,
# test_verify_magic_link

```

### 5. 代码覆盖率

使用 `coverage.py` 工具可以测量测试覆盖率。通常与 `pytest` 集成使用。

1.  **安装**: `pip install coverage pytest-cov`
2.  **运行测试并生成覆盖率报告**:

    ```bash
    pytest --cov=app --cov-report=html
    ```

    这将运行 `app` 目录下的代码，并在 `htmlcov` 目录下生成一个 HTML 报告。
3.  **查看报告**: 在浏览器中打开 `htmlcov/index.html` 文件即可。

### 6. 测试数据

在编写测试时，通常需要准备测试数据。

*   **单元测试**: 对于单元测试，通常使用 Mock 对象来模拟数据，而不是依赖真实数据。
*   **集成测试**: 对于集成测试，可以使用 `pytest` fixture 在测试开始前向测试数据库中插入数据，并在测试结束后清除数据。这确保了测试环境的隔离。

**示例 (conftest.py - 使用 pytest fixture 管理数据库和测试数据)**:

```python
import pytest
from fastapi.testclient import TestClient # 或者 httpx.Client
from app.main import app
# from app.dal.connection import get_db_connection # 假设有获取数据库连接的函数
# from your_test_db_utils import setup_test_database, teardown_test_database # 假设有测试数据库管理工具

@pytest.fixture(scope="session")
def client():
    # yield TestClient(app) # 使用 TestClient
    # 或者使用 httpx.Client
    import httpx
    with httpx.Client(app=app, base_url="http://test") as client:
         yield client

# 假设你需要一个测试数据库和一些初始数据
# @pytest.fixture(scope="session", autouse=True)
# def setup_and_teardown_database():
#     print("Setting up test database...")
#     db_connection = setup_test_database() # 执行数据库初始化脚本，插入基础数据等
#     yield db_connection # 在测试期间可以使用 db_connection
#     print("Tearing down test database...")
#     teardown_test_database(db_connection) # 清除测试数据或删除测试数据库

# TODO: 添加更多用于生成测试数据的 fixtures (如创建测试用户、测试商品等)
# @pytest.fixture
# def test_user(client): # 或者接受 db_connection fixture
#     # 在测试数据库中创建测试用户
#     user_data = {...}
#     # 调用 sp_CreateUser 存储过程 或 API endpoint
#     # 返回创建的用户对象或ID
#     pass

# @pytest.fixture
# def test_product(test_user): # 依赖 test_user fixture
#     # 在测试数据库中创建测试商品，并关联到 test_user
#     # 调用 sp_CreateProduct 存储过程 或 API endpoint
#     # 返回创建的商品对象或ID
#     pass
```

--- 